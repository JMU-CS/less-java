// add : (int, int) -> int
add (a, b) {
    return a + b
}

// eq : ForAll a, (a, a) -> bool
eq (a, b) {
    return a == b
}

// eqBroken : (bool, bool, bool, bool) -> bool
eqBroken (a, b, c, d) {
    return a == b && c == d && b == true && b == c
}

// eqWorks : (bool, bool, bool, bool) -> bool
eqWorks (a, b, c, d) {
    return a == b && c == d && b == c && b == true
}

// eqComposite: ForAll a, ForAll b, (a, a, b, b) -> bool
eqComposite (a, b, c, d) {
    return eq(a, b) && eq(c, d)
}

// eqCompositeConstrained: ForAll a, (a, a, a) -> bool
eqCompositeConstrained (a, b, c) {
    return eq(a, b) && eq(b, c)
}

// compareToInt : (int) -> bool
compareToInt(c) {
    return c == 10
}

add (1, 2)      // ok
eq (1, 2)       // ok; instantiate to (int, int) -> bool

// ok; instantiate to (int, int, int, int) -> bool
eqComposite(1, 2, 3, 4)

// ok; instantiate to (int, int, bool, bool) -> bool
eqComposite(1, 2, true, false)

// ok; instantiate to (int, int, int) -> bool
eqCompositeConstrained(1, 2, 3)
